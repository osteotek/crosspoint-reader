# CrossPoint Reader – Copilot Guide

- **Firmware target**: [README.md](../README.md) describes an ESP32-C3 firmware for the Xteink X4 e-paper reader; everything expects the PlatformIO Arduino stack and a 16 MB flash layout.
- **Build & flash**: use `pio run` (default dev env) and `pio run --target upload` for flashing; release binaries come from the `gh_release` env defined in [platformio.ini](../platformio.ini) which flips `CROSSPOINT_VERSION` to the tagged value.
- **Submodules & libs**: hardware abstractions (battery, input, e-ink display) live in the `open-x4-sdk` submodule and are pulled in through `lib_deps` symlinks; keep that repo updated when pin mappings or drivers change.
- **Startup flow**: [src/main.cpp](../src/main.cpp) configures SPI pins, boots the `EInkDisplay`, registers fonts with `GfxRenderer`, restores persisted state, and chooses the initial `Screen` (boot logo → resume book → file picker).
- **Screen lifecycle**: all UI surfaces derive from `Screen` in [src/screens/Screen.h](../src/screens/Screen.h); only ever swap screens through `exitScreen()`/`enterNewScreen()` so `onExit()` runs before deleting the old instance.
- **Input handling**: `InputManager` (open-x4-sdk) must be polled from the global loop; screens should only react inside `handleInput()` and prefer `wasPressed/wasReleased` plus `getHeldTime()` to avoid repeated actions.
- **Renderer & fonts**: fonts are registered via hashed IDs in [src/config.h](../src/config.h); if you add or replace a font you must recompute the ID comments to avoid collisions and update every `renderer.drawText` call that references that ID.
- **File selection pattern**: [src/screens/FileSelectionScreen.cpp](../src/screens/FileSelectionScreen.cpp) recursively browses `/` on the SD card, filters `.epub`, and sorts directories ahead of files; reuse the `loadFiles()` logic if you add other SD-backed pickers so hidden entries (dotfiles) stay ignored.
- **State persistence**: `CrossPointState` in [src/CrossPointState.cpp](../src/CrossPointState.cpp) serializes the last opened EPUB path to `/sd/.crosspoint/state.bin`; extend this struct with new POD/string fields and bump `STATE_FILE_VERSION` while preserving backward reads.
- **EPUB model**: [lib/Epub/Epub.cpp](../lib/Epub/Epub.cpp) defers parsing by streaming EPUB internals from `/sd/<path>` via `ZipFile`; always prefer `readItemContentsToStream()` when adding parsers to keep heap usage below the ESP32-C3 limits.
- **Caching strategy**: `Epub::setupCacheDir()` builds `/.crosspoint/epub_<hash>` and `Section` (see [lib/Epub/Epub/Section.h](../lib/Epub/Epub/Section.h)) writes `section.bin`/`page_*.bin`; deleting that directory is the supported “clear cache” operation.
- **Reader workflow**: [src/screens/EpubReaderScreen.cpp](../src/screens/EpubReaderScreen.cpp) loads the current spine item, lazily builds page caches, and stores progress in `progress.bin`; any edits to rendering must continue to guard `renderer` calls with `renderingMutex` because a FreeRTOS task is executing `renderScreen()` while the main loop handles inputs.
- **Chapter selection overlay**: `EpubReaderScreen` pushes modal sub-screens (e.g., `EpubReaderChapterSelectionScreen`) by pausing rendering with the semaphore—follow that pattern for any new overlay so the e-ink driver never receives interleaved commands.
- **Partial refresh rules**: `pagesUntilFullRefresh` enforces a full-screen refresh every 15 pages to prevent ghosting; if you change page cadence, update `PAGES_PER_REFRESH` and keep both BW and grayscale passes in sync with `renderer.setFontRenderMode`.
- **Battery & status bar**: `renderStatusBar()` mixes numeric percentage from `battery.readPercentage()` with TOC metadata; make sure any new HUD content still leaves horizontal room between the left battery block and right page counter.
- **File paths & SD assumptions**: all runtime file IO is rooted at `/sd`; ensure anything new (logs, caches) lives under `/.crosspoint/...` to avoid cluttering the user's visible storage and always call `SD.mkdir` for intermediate segments like `Epub::setupCacheDir()` does.
- **Power management**: the firmware will instantly return to deep sleep unless `verifyWakeupLongPress()` confirms the power button is held for $\text{POWER\_BUTTON\_WAKEUP\_MS}$; if you add boot-time logic, keep it after this check, and always re-arm GPIO wakeups before invoking `esp_deep_sleep_start()`.
- **Event loop contract**: keep `loop()` light—anything that touches the display or SD card for long must run in its own FreeRTOS task like the reader/file-picker patterns; otherwise input debouncing and sleep detection will lag.
- **Logging**: follow the `[millis][TAG]` `Serial.printf` style used throughout (e.g., `[ERS]` for EpubReaderScreen) so logs stay grep-friendly when debugging over USB at 115200 baud.
- **Extending screens**: when creating a new `Screen`, allocate any worker task in `onEnter()`, tear it down inside `onExit()` after taking the rendering mutex, and gate expensive refreshes behind an `updateRequired` flag so the task loop mirrors the existing UI components.
- **Submodule coordination**: if you need new hardware capabilities, add them under `open-x4-sdk/libs/...` and reference via `lib_deps` instead of copying code into `src/`; this keeps firmware and SDK revisions aligned across community projects.
