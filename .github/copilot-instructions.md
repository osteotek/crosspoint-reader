# CrossPoint Reader – Copilot Guide

- **Environments & builds**: `pio run` builds the default ESP32-C3 firmware defined in [platformio.ini](../platformio.ini); use `pio run --target upload` for USB flashing, `pio run -e gh_release` to produce release binaries, and `pio test -e native` for host-side unit tests (`env:native` compiles only the test scaffolding under [src/native_unit_sources.cpp](../src/native_unit_sources.cpp)).
- **Flash map expectations**: the board configuration in [platformio.ini](../platformio.ini) assumes 16 MB flash, custom partitions (`partitions.csv`), and USB CDC boot mode; keep offsets intact or the bootloader/OTA flow breaks.
- **Submodules & hardware libs**: abstractions for the display, input, and battery live under [open-x4-sdk](../open-x4-sdk); `lib_deps` symlink them into the build, so update the submodule before editing pin maps or hardware drivers.
- **Startup critical path**: [src/main.cpp](../src/main.cpp) wires up SPI pins, calls `verifyWakeupLongPress()` (device re-enters deep sleep unless the power button is held for $\text{POWER\_BUTTON\_WAKEUP\_MS}$), initializes `EInkDisplay`, registers fonts with `GfxRenderer`, restores [CrossPointState](../src/CrossPointState.cpp), and chooses the first `Screen`.
- **Power & sleep**: always call `waitForPowerRelease()` before leaving `setup()` and re-arm GPIO wakeups via `esp_deep_sleep_enable_gpio_wakeup()` before invoking `esp_deep_sleep_start()`; `enterDeepSleep()` swaps to [src/screens/SleepScreen.cpp](../src/screens/SleepScreen.cpp) for the final render.
- **Screen contract**: every UI surface derives from [src/screens/Screen.h](../src/screens/Screen.h); transition via `exitScreen()`/`enterNewScreen()` so `onExit()` runs, and never delete a screen without first stopping its FreeRTOS task and releasing the display semaphore.
- **Main loop rules**: `loop()` in [src/main.cpp](../src/main.cpp) only polls `InputManager`, checks power-button timing, and delegates to `currentScreen->handleInput()`; any SD or rendering work belongs in the screen’s internal task to keep input debouncing responsive.
- **Input handling**: prefer `wasPressed`/`wasReleased` alongside `getHeldTime()` to disambiguate taps vs. long presses (see [src/screens/EpubReaderScreen.cpp](../src/screens/EpubReaderScreen.cpp) for the skip-chapter timing pattern and [src/screens/FileSelectionScreen.cpp](../src/screens/FileSelectionScreen.cpp) for cursor wrapping).
- **Renderer & fonts**: font IDs in [src/config.h](../src/config.h) are SHA-derived constants; if you change any builtin font headers you must recompute the comments’ Ruby snippets and update every `renderer.drawText` call using those IDs.
- **File selection pattern**: [src/screens/FileSelectionScreen.cpp](../src/screens/FileSelectionScreen.cpp) lists `/sd` entries, filters dotfiles, appends `/` to directories, sorts with directories first, and keeps a `selectorIndex`; reuse `loadFiles()` rather than writing bespoke SD walkers so navigation stays consistent.
- **State & persistence**: [src/CrossPointState.cpp](../src/CrossPointState.cpp) writes `/sd/.crosspoint/state.bin` via `serialization::writePod`; bump `STATE_FILE_VERSION`, keep the file POD-only, and tolerate unknown versions by logging then aborting the load.
- **EPUB streaming**: [lib/Epub/Epub.cpp](../lib/Epub/Epub.cpp) never loads full files into RAM—use `ZipFile::readFileToStream()` for new parsers (`ContainerParser`, `ContentOpfParser`, `TocNcxParser`) and update `normalisePath()` logic if you introduce new href patterns.
- **Caching & SD layout**: `Epub::setupCacheDir()` ensures `/.crosspoint/epub_<hash>` exists, `Section` (see [lib/Epub/Epub/Section.h](../lib/Epub/Epub/Section.h)) stores `section.bin` plus `page_*.bin`, and `progress.bin` tracks `(spineIndex,page)` pairs (written in [src/screens/EpubReaderScreen.cpp](../src/screens/EpubReaderScreen.cpp)); clearing that directory is the supported “reset book” workflow.
- **Section rendering**: `EpubReaderScreen` offloads drawing to a FreeRTOS task guarded by `renderingMutex`; take the semaphore (see `SemaphoreGuard`) before mutating `section` or `subScreen` to prevent interleaved SPI commands.
- **Page refresh cadence**: `PAGES_PER_REFRESH` currently equals 15; `renderContents()` performs a BW buffer refresh followed by grayscale LSB/MSB passes, so keep `pagesUntilFullRefresh` and the grayscale copies in sync whenever you change pagination.
- **Status bar layout**: `renderStatusBar()` draws battery percentage using `battery.readPercentage()` plus the current chapter title centered between the battery glyph and the right-aligned `pageCount`; any HUD additions must respect that horizontal spacing budget.
- **Modal overlays**: temporary UI (e.g., [src/screens/EpubReaderChapterSelectionScreen.cpp](../src/screens/EpubReaderChapterSelectionScreen.cpp)) pauses the main renderer by grabbing `renderingMutex`, instantiates a child `Screen`, and tears it down via callbacks so the parent resumes with `updateRequired = true`.
- **File/SD hygiene**: every runtime path is rooted at `/sd`; stash app data under `/.crosspoint/...`, call `SD.mkdir` for each missing segment (see `setupCacheDir()`), and never blockingly recurse from the UI thread.
- **Logging convention**: stick to `[millis][TAG]` `Serial.printf` lines (`[ERS]`, `[EBP]`, `[CPS]`, etc.) so USB logs stay searchable; long operations should log start/stop plus durations (see `renderScreen()` timing output).
- **Extending hardware**: add new device drivers to `open-x4-sdk/libs/...` and reference them through `lib_deps` instead of copying code into [src](../src); this keeps the firmware aligned with other community projects.
- **Troubleshooting checklist**: if the device instantly re-sleeps, verify the power button long-press window and that `/sd/.crosspoint` exists; rendering glitches usually trace back to missing semaphore holds or stale cache directories—clear `/.crosspoint/epub_*` and confirm `Section::persistPageDataToSD()` reruns.
